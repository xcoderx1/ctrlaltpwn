<#
.SYNOPSIS
    Windows Privilege Escalation Enumeration Tool
.DESCRIPTION
    Enumerates system information to identify potential privilege escalation vectors
.NOTES
    For authorized security assessments only
#>

param(
    [switch]$Verbose,
    [switch]$SaveReport,
    [string]$OutputPath = ".\PrivEscEnum_Report.txt"
)

# Color coding for output
function Write-Finding {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    switch ($Level) {
        "Critical" { Write-Host "[!] $Message" -ForegroundColor Red }
        "High"     { Write-Host "[+] $Message" -ForegroundColor Yellow }
        "Medium"   { Write-Host "[*] $Message" -ForegroundColor Cyan }
        "Info"     { Write-Host "[i] $Message" -ForegroundColor White }
    }
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "[$Level] $Message"
    }
}

function Write-SectionHeader {
    param([string]$Title)
    $separator = "=" * 80
    Write-Host "`n$separator" -ForegroundColor Green
    Write-Host $Title -ForegroundColor Green
    Write-Host "$separator`n" -ForegroundColor Green
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "`n$separator`n$Title`n$separator`n"
    }
}

# Initialize report
if ($SaveReport) {
    "Windows Privilege Escalation Enumeration Report" | Out-File -FilePath $OutputPath
    "Generated: $(Get-Date)" | Out-File -FilePath $OutputPath -Append
    "Host: $env:COMPUTERNAME" | Out-File -FilePath $OutputPath -Append
}

Write-Host @"
 _    _ _       _____      _       ______                       
| |  | (_)     |  __ \    (_)     |  ____|                      
| |  | |_ _ __ | |__) | __ ___   _| |__   _ __  _   _ _ __ ___  
| |  | | | '_ \|  ___/ '__| \ \ / /  __| | '_ \| | | | '_ ` _ \ 
| |__| | | | | | |   | |  | |\ V /| |____| | | | |_| | | | | | |
 \____/|_|_| |_|_|   |_|  |_| \_/ |______|_| |_|\__,_|_| |_| |_|
                                                                  
        Windows Privilege Escalation Enumeration Tool
"@ -ForegroundColor Cyan

# ============================================================================
# SYSTEM INFORMATION
# ============================================================================
Write-SectionHeader "SYSTEM INFORMATION"

try {
    $os = Get-WmiObject -Class Win32_OperatingSystem
    Write-Finding "OS: $($os.Caption) $($os.OSArchitecture)" "Info"
    Write-Finding "Version: $($os.Version)" "Info"
    Write-Finding "Build: $($os.BuildNumber)" "Info"
    Write-Finding "Hostname: $env:COMPUTERNAME" "Info"
    
    # Check for missing hotfixes
    Write-Finding "Checking installed hotfixes..." "Info"
    $hotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
    Write-Finding "Total Hotfixes Installed: $($hotfixes.Count)" "Info"
    
} catch {
    Write-Finding "Error gathering system information: $_" "High"
}

# ============================================================================
# CURRENT USER INFORMATION
# ============================================================================
Write-SectionHeader "CURRENT USER INFORMATION"

try {
    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    Write-Finding "Username: $($currentUser.Name)" "Info"
    
    # Check privileges
    $privileges = whoami /priv
    Write-Finding "User Privileges:" "Info"
    $privileges | ForEach-Object { Write-Finding $_ "Info" }
    
    # Check group memberships
    Write-Finding "`nGroup Memberships:" "Info"
    $groups = whoami /groups
    $groups | ForEach-Object { Write-Finding $_ "Info" }
    
    # Check for interesting privileges
    if ($privileges -match "SeImpersonatePrivilege.*Enabled") {
        Write-Finding "SeImpersonatePrivilege is ENABLED - Potential token impersonation attack!" "Critical"
    }
    if ($privileges -match "SeDebugPrivilege.*Enabled") {
        Write-Finding "SeDebugPrivilege is ENABLED - Can debug processes!" "High"
    }
    if ($privileges -match "SeBackupPrivilege.*Enabled") {
        Write-Finding "SeBackupPrivilege is ENABLED - Can backup sensitive files!" "High"
    }
    if ($privileges -match "SeRestorePrivilege.*Enabled") {
        Write-Finding "SeRestorePrivilege is ENABLED - Can restore files!" "High"
    }
    if ($privileges -match "SeTakeOwnershipPrivilege.*Enabled") {
        Write-Finding "SeTakeOwnershipPrivilege is ENABLED - Can take ownership of objects!" "High"
    }
    
} catch {
    Write-Finding "Error gathering user information: $_" "High"
}

# ============================================================================
# ALWAYSINSTALLELEVATED REGISTRY CHECK
# ============================================================================
Write-SectionHeader "ALWAYSINSTALLELEVATED CHECK"

try {
    $hklm = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    $hkcu = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    
    if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
        Write-Finding "VULNERABLE! AlwaysInstallElevated is enabled in both HKLM and HKCU!" "Critical"
        Write-Finding "MSI packages can be installed with SYSTEM privileges!" "Critical"
    } else {
        Write-Finding "AlwaysInstallElevated is not enabled" "Info"
    }
} catch {
    Write-Finding "Could not check AlwaysInstallElevated registry keys" "Info"
}

# ============================================================================
# SERVICES ENUMERATION
# ============================================================================
Write-SectionHeader "SERVICES WITH POTENTIAL ISSUES"

try {
    Write-Finding "Checking for services with weak permissions..." "Info"
    
    $services = Get-WmiObject win32_service | Where-Object {$_.State -eq "Running"}
    
    foreach ($service in $services) {
        # Check for unquoted service paths
        if ($service.PathName -match '^[^"].*\s.*') {
            Write-Finding "Unquoted Service Path: $($service.Name) - $($service.PathName)" "High"
        }
        
        # Check if service binary path is writable (simplified check)
        if ($service.PathName) {
            $binaryPath = $service.PathName -replace '"', '' -replace ' .*$', ''
            if (Test-Path $binaryPath -ErrorAction SilentlyContinue) {
                try {
                    $acl = Get-Acl $binaryPath -ErrorAction SilentlyContinue
                    $writableByUser = $acl.Access | Where-Object {
                        ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                        ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                    }
                    
                    if ($writableByUser) {
                        Write-Finding "Writable Service Binary: $($service.Name) - $binaryPath" "Critical"
                    }
                } catch {}
            }
        }
    }
    
    # Check service permissions using sc
    Write-Finding "`nChecking for services with weak ACLs..." "Info"
    $modifiableServices = Get-WmiObject win32_service | ForEach-Object {
        $serviceName = $_.Name
        try {
            $sdResult = & sc.exe sdshow $serviceName 2>$null
            if ($sdResult -match "WD") {
                Write-Finding "Service '$serviceName' has weak permissions (Everyone has access)" "High"
            }
        } catch {}
    }
    
} catch {
    Write-Finding "Error enumerating services: $_" "High"
}

# ============================================================================
# SCHEDULED TASKS
# ============================================================================
Write-SectionHeader "SCHEDULED TASKS"

try {
    Write-Finding "Checking for scheduled tasks with weak permissions..." "Info"
    
    $tasks = Get-ScheduledTask | Where-Object {$_.State -eq "Ready"}
    
    foreach ($task in $tasks) {
        if ($task.Principal.UserId -eq "SYSTEM" -or $task.Principal.UserId -eq "NT AUTHORITY\SYSTEM") {
            $actions = $task.Actions
            foreach ($action in $actions) {
                if ($action.Execute) {
                    $execPath = $action.Execute
                    if (Test-Path $execPath -ErrorAction SilentlyContinue) {
                        try {
                            $acl = Get-Acl $execPath -ErrorAction SilentlyContinue
                            $writableByUser = $acl.Access | Where-Object {
                                ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                            }
                            
                            if ($writableByUser) {
                                Write-Finding "Writable SYSTEM Task: $($task.TaskName) - $execPath" "Critical"
                            }
                        } catch {}
                    }
                }
            }
        }
    }
} catch {
    Write-Finding "Error checking scheduled tasks: $_" "High"
}

# ============================================================================
# WRITABLE DIRECTORIES IN PATH
# ============================================================================
Write-SectionHeader "WRITABLE DIRECTORIES IN PATH"

try {
    $pathDirs = $env:PATH -split ";"
    
    foreach ($dir in $pathDirs) {
        if ($dir -and (Test-Path $dir -ErrorAction SilentlyContinue)) {
            try {
                $acl = Get-Acl $dir -ErrorAction SilentlyContinue
                $writableByUser = $acl.Access | Where-Object {
                    ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                    ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users|$env:USERNAME")
                }
                
                if ($writableByUser) {
                    Write-Finding "Writable PATH directory: $dir" "High"
                }
            } catch {}
        }
    }
} catch {
    Write-Finding "Error checking PATH directories: $_" "High"
}

# ============================================================================
# AUTORUN ENTRIES
# ============================================================================
Write-SectionHeader "AUTORUN ENTRIES"

try {
    Write-Finding "Checking common autorun locations..." "Info"
    
    $autorunKeys = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
    )
    
    foreach ($key in $autorunKeys) {
        if (Test-Path $key) {
            $entries = Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
            if ($entries) {
                Write-Finding "`nAutorun entries in $key" "Info"
                $entries.PSObject.Properties | Where-Object {$_.Name -notmatch "^PS"} | ForEach-Object {
                    Write-Finding "$($_.Name): $($_.Value)" "Medium"
                    
                    # Check if the file is writable
                    $filePath = $_.Value -replace '"', '' -replace ' .*$', ''
                    if (Test-Path $filePath -ErrorAction SilentlyContinue) {
                        try {
                            $acl = Get-Acl $filePath -ErrorAction SilentlyContinue
                            $writableByUser = $acl.Access | Where-Object {
                                ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                            }
                            
                            if ($writableByUser) {
                                Write-Finding "  ^-- File is WRITABLE!" "Critical"
                            }
                        } catch {}
                    }
                }
            }
        }
    }
} catch {
    Write-Finding "Error checking autorun entries: $_" "High"
}

# ============================================================================
# INTERESTING FILES
# ============================================================================
Write-SectionHeader "SEARCHING FOR INTERESTING FILES"

try {
    Write-Finding "Searching for credential files..." "Info"
    
    # Common credential locations
    $interestingFiles = @(
        "$env:USERPROFILE\Unattend.xml",
        "C:\Unattend.xml",
        "C:\Windows\Panther\Unattend.xml",
        "C:\Windows\Panther\Unattend\Unattend.xml",
        "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
    )
    
    foreach ($file in $interestingFiles) {
        if (Test-Path $file -ErrorAction SilentlyContinue) {
            Write-Finding "Found: $file" "High"
        }
    }
    
    # Search for config files with passwords
    Write-Finding "`nSearching for config files in common locations..." "Info"
    $searchPaths = @("$env:USERPROFILE", "C:\inetpub", "C:\xampp")
    $configExtensions = @("*.config", "*.xml", "*.ini", "*.txt")
    
    foreach ($path in $searchPaths) {
        if (Test-Path $path -ErrorAction SilentlyContinue) {
            foreach ($ext in $configExtensions) {
                Get-ChildItem -Path $path -Filter $ext -Recurse -ErrorAction SilentlyContinue -Depth 2 | 
                    Where-Object {$_.Length -lt 1MB} | 
                    Select-Object -First 10 | 
                    ForEach-Object {
                        $content = Get-Content $_.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "password|pwd|pass" -SimpleMatch
                        if ($content) {
                            Write-Finding "Potential credentials in: $($_.FullName)" "High"
                        }
                    }
            }
        }
    }
    
} catch {
    Write-Finding "Error searching for interesting files: $_" "High"
}

# ============================================================================
# NETWORK INFORMATION
# ============================================================================
Write-SectionHeader "NETWORK INFORMATION"

try {
    Write-Finding "Network Interfaces:" "Info"
    Get-NetIPAddress | Where-Object {$_.AddressFamily -eq "IPv4"} | ForEach-Object {
        Write-Finding "$($_.InterfaceAlias): $($_.IPAddress)" "Info"
    }
    
    Write-Finding "`nActive Network Connections:" "Info"
    Get-NetTCPConnection | Where-Object {$_.State -eq "Established"} | 
        Select-Object -First 20 LocalAddress,LocalPort,RemoteAddress,RemotePort,State | 
        ForEach-Object {
            Write-Finding "$($_.LocalAddress):$($_.LocalPort) -> $($_.RemoteAddress):$($_.RemotePort) [$($_.State)]" "Info"
        }
    
    Write-Finding "`nListening Ports:" "Info"
    Get-NetTCPConnection | Where-Object {$_.State -eq "Listen"} | 
        Select-Object LocalAddress,LocalPort | 
        ForEach-Object {
            Write-Finding "$($_.LocalAddress):$($_.LocalPort)" "Info"
        }
        
} catch {
    Write-Finding "Error gathering network information: $_" "High"
}

# ============================================================================
# INSTALLED APPLICATIONS
# ============================================================================
Write-SectionHeader "INSTALLED APPLICATIONS"

try {
    Write-Finding "Checking installed applications..." "Info"
    
    $apps = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
            Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
            Where-Object {$_.DisplayName} | 
            Sort-Object DisplayName
    
    $apps | Select-Object -First 30 | ForEach-Object {
        Write-Finding "$($_.DisplayName) - Version: $($_.DisplayVersion)" "Info"
    }
    
    Write-Finding "`nTotal applications found: $($apps.Count)" "Info"
    
} catch {
    Write-Finding "Error enumerating installed applications: $_" "High"
}

# ============================================================================
# SAVED CREDENTIALS
# ============================================================================
Write-SectionHeader "SAVED CREDENTIALS"

try {
    Write-Finding "Checking for saved credentials..." "Info"
    
    $savedCreds = cmdkey /list
    if ($savedCreds) {
        Write-Finding "Saved credentials found:" "High"
        $savedCreds | ForEach-Object { Write-Finding $_ "High" }
    } else {
        Write-Finding "No saved credentials found" "Info"
    }
    
} catch {
    Write-Finding "Error checking saved credentials: $_" "High"
}

# ============================================================================
# ADVANCED PASSWORD HUNTING
# ============================================================================
Write-SectionHeader "ADVANCED PASSWORD HUNTING"

try {
    Write-Finding "Searching for credentials in registry..." "Info"
    
    # VNC Passwords
    $vncKeys = @(
        "HKCU:\Software\ORL\WinVNC3\Password",
        "HKCU:\Software\RealVNC\WinVNC4",
        "HKLM:\SOFTWARE\RealVNC\WinVNC4"
    )
    
    foreach ($key in $vncKeys) {
        if (Test-Path $key -ErrorAction SilentlyContinue) {
            Write-Finding "VNC registry key found: $key" "High"
        }
    }
    
    # PuTTY Sessions
    $puttyKey = "HKCU:\Software\SimonTatham\PuTTY\Sessions"
    if (Test-Path $puttyKey -ErrorAction SilentlyContinue) {
        Write-Finding "PuTTY sessions found in registry" "High"
        Get-ChildItem -Path $puttyKey -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  Session: $($_.PSChildName)" "Medium"
        }
    }
    
    # Windows Autologon
    $autologon = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -ErrorAction SilentlyContinue
    if ($autologon.DefaultUserName) {
        Write-Finding "AutoLogon configured for user: $($autologon.DefaultUserName)" "High"
        if ($autologon.DefaultPassword) {
            Write-Finding "AutoLogon password found in registry!" "Critical"
        }
    }
    
    # SNMP Community Strings
    $snmpKey = "HKLM:\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ValidCommunities"
    if (Test-Path $snmpKey -ErrorAction SilentlyContinue) {
        Write-Finding "SNMP community strings found in registry" "High"
    }
    
    # WiFi Passwords
    Write-Finding "`nExtracting WiFi passwords..." "Info"
    $wifiProfiles = netsh wlan show profiles | Select-String "All User Profile" | ForEach-Object {
        $_ -replace ".*:\s+"
    }
    
    foreach ($profile in $wifiProfiles) {
        $profileInfo = netsh wlan show profile name="$profile" key=clear
        $password = $profileInfo | Select-String "Key Content" | ForEach-Object {
            $_ -replace ".*:\s+"
        }
        if ($password) {
            Write-Finding "WiFi Profile: $profile - Password: $password" "High"
        }
    }
    
    # IIS Application Pools
    $iisConfig = "C:\Windows\System32\inetsrv\config\applicationHost.config"
    if (Test-Path $iisConfig -ErrorAction SilentlyContinue) {
        Write-Finding "IIS configuration file found: $iisConfig" "High"
        $content = Get-Content $iisConfig -ErrorAction SilentlyContinue | Select-String -Pattern "password|connectionString"
        if ($content) {
            Write-Finding "Potential credentials found in IIS config" "Critical"
        }
    }
    
    # Search for web.config files
    Write-Finding "`nSearching for web.config files with connection strings..." "Info"
    $webConfigs = Get-ChildItem -Path "C:\inetpub" -Filter "web.config" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 10
    foreach ($config in $webConfigs) {
        $content = Get-Content $config.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "connectionString|password"
        if ($content) {
            Write-Finding "Credentials in: $($config.FullName)" "High"
        }
    }
    
    # Database connection files
    Write-Finding "`nSearching for database connection files..." "Info"
    $dbFiles = @("*.udl", "*.dsn")
    foreach ($ext in $dbFiles) {
        Get-ChildItem -Path "C:\" -Filter $ext -Recurse -ErrorAction SilentlyContinue -Depth 3 | 
            Select-Object -First 5 | 
            ForEach-Object {
                Write-Finding "Database file found: $($_.FullName)" "High"
            }
    }
    
    # Registry - Run keys passwords
    $runKeys = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
    )
    foreach ($key in $runKeys) {
        if (Test-Path $key) {
            $entries = Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
            $entries.PSObject.Properties | Where-Object {$_.Value -match "password|/p\s|/pass"} | ForEach-Object {
                Write-Finding "Potential password in Run key: $($_.Name) = $($_.Value)" "High"
            }
        }
    }
    
} catch {
    Write-Finding "Error in advanced password hunting: $_" "High"
}

# ============================================================================
# PROCESS ENUMERATION
# ============================================================================
Write-SectionHeader "PROCESS ENUMERATION"

try {
    Write-Finding "Enumerating running processes..." "Info"
    
    $processes = Get-WmiObject Win32_Process
    
    # SYSTEM processes
    Write-Finding "`nProcesses running as SYSTEM:" "Info"
    $systemProcs = $processes | Where-Object {
        $owner = $_.GetOwner()
        $owner.User -eq "SYSTEM"
    } | Select-Object ProcessId, Name, CommandLine -First 20
    
    foreach ($proc in $systemProcs) {
        Write-Finding "PID $($proc.ProcessId): $($proc.Name)" "Medium"
    }
    
    # Processes with potentially exploitable paths
    Write-Finding "`nProcesses with unquoted paths containing spaces:" "Info"
    $processes | Where-Object {
        $_.ExecutablePath -match '^\w:\\[^"]*\s.*\.exe' -and $_.ExecutablePath -notmatch '^"'
    } | ForEach-Object {
        Write-Finding "PID $($_.ProcessId): $($_.Name) - $($_.ExecutablePath)" "High"
    }
    
    # Check for interesting process names
    $interestingProcs = @("sql", "postgres", "mysql", "oracle", "mongo", "redis", "elastic")
    foreach ($keyword in $interestingProcs) {
        $found = $processes | Where-Object {$_.Name -like "*$keyword*"}
        if ($found) {
            Write-Finding "Database/Service process found: $($found.Name)" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error enumerating processes: $_" "High"
}

# ============================================================================
# TOKEN PRIVILEGES & IMPERSONATION
# ============================================================================
Write-SectionHeader "TOKEN PRIVILEGES & IMPERSONATION OPPORTUNITIES"

try {
    Write-Finding "Analyzing token privileges for exploitation..." "Info"
    
    # Get current token privileges
    $tokenPrivs = whoami /priv | Select-String "Enabled"
    
    # Check for specific dangerous privileges
    $dangerousPrivs = @{
        "SeImpersonatePrivilege" = "Token impersonation (Potato attacks, PrintSpoofer)"
        "SeAssignPrimaryTokenPrivilege" = "Assign primary token"
        "SeTcbPrivilege" = "Act as part of the operating system"
        "SeBackupPrivilege" = "Backup files and directories (can read any file)"
        "SeRestorePrivilege" = "Restore files and directories (can write any file)"
        "SeCreateTokenPrivilege" = "Create a token object"
        "SeLoadDriverPrivilege" = "Load and unload device drivers"
        "SeTakeOwnershipPrivilege" = "Take ownership of files or objects"
        "SeDebugPrivilege" = "Debug programs (inject into processes)"
    }
    
    foreach ($priv in $dangerousPrivs.Keys) {
        if ($tokenPrivs -match $priv) {
            Write-Finding "$priv is ENABLED - $($dangerousPrivs[$priv])" "Critical"
        }
    }
    
    # Check if we can access SYSTEM process tokens
    Write-Finding "`nChecking for accessible SYSTEM processes..." "Info"
    $systemProcesses = Get-Process | Where-Object {
        try {
            $_.Handle -ne $null
        } catch {
            $false
        }
    }
    
    Write-Finding "Accessible processes: $($systemProcesses.Count)" "Info"
    
} catch {
    Write-Finding "Error analyzing token privileges: $_" "High"
}

# ============================================================================
# DLL HIJACKING OPPORTUNITIES
# ============================================================================
Write-SectionHeader "DLL HIJACKING OPPORTUNITIES"

try {
    Write-Finding "Searching for DLL hijacking opportunities..." "Info"
    
    # Check PATH for writable directories (already done above, but check DLL specifically)
    Write-Finding "`nChecking for writable directories in PATH (DLL hijacking)..." "Info"
    $pathDirs = $env:PATH -split ";"
    foreach ($dir in $pathDirs) {
        if ($dir -and (Test-Path $dir -ErrorAction SilentlyContinue)) {
            try {
                $testFile = Join-Path $dir "test_write_$(Get-Random).dll"
                New-Item -Path $testFile -ItemType File -ErrorAction Stop | Out-Null
                Remove-Item -Path $testFile -ErrorAction SilentlyContinue
                Write-Finding "WRITABLE PATH directory for DLL planting: $dir" "Critical"
            } catch {}
        }
    }
    
    # Check common application directories
    Write-Finding "`nChecking Program Files for weak permissions..." "Info"
    $programDirs = @(
        "C:\Program Files",
        "C:\Program Files (x86)"
    )
    
    foreach ($baseDir in $programDirs) {
        if (Test-Path $baseDir) {
            Get-ChildItem -Path $baseDir -Directory -ErrorAction SilentlyContinue | Select-Object -First 20 | ForEach-Object {
                try {
                    $acl = Get-Acl $_.FullName -ErrorAction SilentlyContinue
                    $writable = $acl.Access | Where-Object {
                        ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                        ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                    }
                    
                    if ($writable) {
                        Write-Finding "Writable application directory: $($_.FullName)" "High"
                    }
                } catch {}
            }
        }
    }
    
    # Check for missing DLLs in running processes
    Write-Finding "`nChecking for missing DLLs (phantom DLL opportunities)..." "Info"
    $processes = Get-Process | Select-Object -First 30
    foreach ($proc in $processes) {
        try {
            $modules = $proc.Modules | Select-Object -ExpandProperty FileName
            # This is a simplified check - in reality, you'd need to monitor file access
        } catch {}
    }
    Write-Finding "Note: Use Process Monitor to identify missing DLLs in real scenarios" "Info"
    
} catch {
    Write-Finding "Error checking DLL hijacking opportunities: $_" "High"
}

# ============================================================================
# KERNEL EXPLOIT DETECTION
# ============================================================================
Write-SectionHeader "KERNEL EXPLOIT DETECTION"

try {
    Write-Finding "Mapping OS version to known kernel exploits..." "Info"
    
    $os = Get-WmiObject -Class Win32_OperatingSystem
    $buildNumber = $os.BuildNumber
    $osVersion = $os.Version
    
    Write-Finding "OS Build: $buildNumber" "Info"
    
    # Known exploits database
    $exploits = @{
        "7600" = @("MS10-015", "MS10-092", "MS11-011", "MS11-046")
        "7601" = @("MS11-011", "MS11-046", "MS11-080", "MS13-005", "MS13-053", "MS13-081", "MS14-058", "MS15-051", "MS16-014", "MS16-032")
        "9200" = @("MS13-053", "MS13-081", "MS14-058", "MS15-051", "MS16-014", "MS16-032")
        "9600" = @("MS14-058", "MS15-051", "MS16-014", "MS16-032", "MS16-034", "MS16-135")
        "10240" = @("MS16-032", "MS16-034", "MS16-135")
        "10586" = @("MS16-032", "MS16-034", "MS16-135")
        "14393" = @("MS16-135", "CVE-2017-0213")
        "15063" = @("CVE-2017-0213")
        "16299" = @("CVE-2018-0743", "CVE-2018-8120")
        "17134" = @("CVE-2018-8440", "CVE-2018-8611")
        "17763" = @("CVE-2019-0841", "CVE-2019-1064", "CVE-2019-1130")
        "18362" = @("CVE-2019-1064", "CVE-2019-1130", "CVE-2019-1253", "CVE-2019-1315")
        "18363" = @("CVE-2019-1253", "CVE-2019-1315", "CVE-2020-0668", "CVE-2020-0683")
        "19041" = @("CVE-2020-0668", "CVE-2020-0683", "CVE-2020-1054")
        "19042" = @("CVE-2020-1054", "CVE-2021-1732")
        "19043" = @("CVE-2021-1732")
        "19044" = @("CVE-2021-1732")
        "22000" = @("CVE-2021-36934 (HiveNightmare/SeriousSAM)")
    }
    
    if ($exploits.ContainsKey($buildNumber)) {
        Write-Finding "`nPotentially vulnerable to the following exploits:" "Critical"
        foreach ($exploit in $exploits[$buildNumber]) {
            Write-Finding "  - $exploit" "Critical"
        }
    } else {
        Write-Finding "Build number not in known vulnerable builds database (might be patched or too new)" "Info"
    }
    
    # Check for specific hotfixes
    Write-Finding "`nChecking for critical security patches..." "Info"
    $criticalPatches = @("KB2503665", "KB3139914", "KB2592799", "KB3178034")
    $installedHotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
    
    foreach ($patch in $criticalPatches) {
        if ($installedHotfixes -notcontains $patch) {
            Write-Finding "Critical patch $patch is NOT installed!" "High"
        }
    }
    
} catch {
    Write-Finding "Error detecting kernel exploits: $_" "High"
}

# ============================================================================
# NAMED PIPES ENUMERATION
# ============================================================================
Write-SectionHeader "NAMED PIPES ENUMERATION"

try {
    Write-Finding "Enumerating accessible named pipes..." "Info"
    
    $pipes = [System.IO.Directory]::GetFiles("\\.\\pipe\\")
    
    Write-Finding "Total named pipes found: $($pipes.Count)" "Info"
    
    # Look for interesting pipes
    $interestingPipes = @("lsass", "sam", "winreg", "spoolss", "srvsvc", "ntsvcs", "scerpc", "wkssvc")
    
    foreach ($pipe in $pipes) {
        $pipeName = [System.IO.Path]::GetFileName($pipe)
        foreach ($interesting in $interestingPipes) {
            if ($pipeName -like "*$interesting*") {
                Write-Finding "Interesting pipe found: $pipeName" "Medium"
            }
        }
    }
    
    # Check pipe permissions (requires more advanced code)
    Write-Finding "`nNote: Use tools like 'accesschk.exe' or 'PipeList' for detailed pipe ACL analysis" "Info"
    
} catch {
    Write-Finding "Error enumerating named pipes: $_" "High"
}

# ============================================================================
# DRIVER ENUMERATION
# ============================================================================
Write-SectionHeader "DRIVER ENUMERATION"

try {
    Write-Finding "Enumerating installed drivers..." "Info"
    
    $drivers = Get-WindowsDriver -Online -All | Select-Object Driver, ProviderName, Date, Version
    
    Write-Finding "Total drivers: $($drivers.Count)" "Info"
    
    # Look for third-party drivers
    Write-Finding "`nThird-party drivers (non-Microsoft):" "Info"
    $thirdPartyDrivers = $drivers | Where-Object {$_.ProviderName -notmatch "Microsoft"} | Select-Object -First 20
    
    foreach ($driver in $thirdPartyDrivers) {
        Write-Finding "$($driver.Driver) - $($driver.ProviderName) - Version: $($driver.Version)" "Medium"
    }
    
    # Check driver signing
    Write-Finding "`nChecking driver signing status..." "Info"
    $unsigned = driverquery /v /fo csv | ConvertFrom-Csv | Where-Object {$_.Signed -eq "False"}
    
    if ($unsigned) {
        Write-Finding "Unsigned drivers found:" "High"
        $unsigned | Select-Object -First 10 | ForEach-Object {
            Write-Finding "$($_.'Module Name') - $($_.'Display Name')" "High"
        }
    } else {
        Write-Finding "All drivers appear to be signed" "Info"
    }
    
    # Known vulnerable drivers
    $vulnDrivers = @("rtcore64.sys", "gdrv.sys", "atillk64.sys", "cpuz141", "asmmap64.sys")
    Write-Finding "`nChecking for known vulnerable drivers..." "Info"
    
    $driverList = driverquery | Out-String
    foreach ($vuln in $vulnDrivers) {
        if ($driverList -match $vuln) {
            Write-Finding "VULNERABLE DRIVER FOUND: $vuln (potential BYOVD attack)" "Critical"
        }
    }
    
} catch {
    Write-Finding "Error enumerating drivers: $_" "High"
}

# ============================================================================
# GPO & SECURITY POLICY ANALYSIS
# ============================================================================
Write-SectionHeader "GPO & SECURITY POLICY ANALYSIS"

try {
    Write-Finding "Analyzing Group Policy and Security settings..." "Info"
    
    # Audit Policy
    Write-Finding "`nAudit Policy Settings:" "Info"
    $auditPol = auditpol /get /category:*
    $auditPol | ForEach-Object { Write-Finding $_ "Info" }
    
    # UAC Status
    $uacReg = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -ErrorAction SilentlyContinue
    
    Write-Finding "`nUAC Settings:" "Info"
    if ($uacReg.EnableLUA -eq 0) {
        Write-Finding "UAC is DISABLED!" "Critical"
    } else {
        Write-Finding "UAC is enabled" "Info"
        Write-Finding "ConsentPromptBehaviorAdmin: $($uacReg.ConsentPromptBehaviorAdmin)" "Info"
        Write-Finding "PromptOnSecureDesktop: $($uacReg.PromptOnSecureDesktop)" "Info"
    }
    
    # LSA Protection
    Write-Finding "`nLSA Protection Status:" "Info"
    $lsaProtection = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name RunAsPPL -ErrorAction SilentlyContinue
    if ($lsaProtection.RunAsPPL -eq 1) {
        Write-Finding "LSA Protection is ENABLED (RunAsPPL)" "Info"
    } else {
        Write-Finding "LSA Protection is DISABLED - credential dumping may be easier" "High"
    }
    
    # Credential Guard
    Write-Finding "`nCredential Guard Status:" "Info"
    $credGuard = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name LsaCfgFlags -ErrorAction SilentlyContinue
    if ($credGuard.LsaCfgFlags -eq 1 -or $credGuard.LsaCfgFlags -eq 2) {
        Write-Finding "Credential Guard is ENABLED" "Info"
    } else {
        Write-Finding "Credential Guard is DISABLED - credentials may be vulnerable" "High"
    }
    
    # Windows Defender status
    Write-Finding "`nWindows Defender Status:" "Info"
    try {
        $defender = Get-MpComputerStatus -ErrorAction SilentlyContinue
        if ($defender) {
            Write-Finding "RealTimeProtectionEnabled: $($defender.RealTimeProtectionEnabled)" "Info"
            Write-Finding "AntivirusEnabled: $($defender.AntivirusEnabled)" "Info"
            if (-not $defender.RealTimeProtectionEnabled) {
                Write-Finding "Real-time protection is DISABLED!" "High"
            }
        }
    } catch {
        Write-Finding "Could not query Windows Defender status" "Info"
    }
    
    # PowerShell logging
    Write-Finding "`nPowerShell Security Settings:" "Info"
    $psLogging = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -ErrorAction SilentlyContinue
    if ($psLogging.EnableScriptBlockLogging -eq 1) {
        Write-Finding "PowerShell Script Block Logging is ENABLED" "Info"
    } else {
        Write-Finding "PowerShell Script Block Logging is DISABLED" "Medium"
    }
    
    $psTranscription = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -ErrorAction SilentlyContinue
    if ($psTranscription.EnableTranscripting -eq 1) {
        Write-Finding "PowerShell Transcription is ENABLED" "Info"
    } else {
        Write-Finding "PowerShell Transcription is DISABLED" "Medium"
    }
    
    # WSUS Configuration (potential MitM)
    Write-Finding "`nWSUS Configuration:" "Info"
    $wsus = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -ErrorAction SilentlyContinue
    if ($wsus.WUServer -match "^http://") {
        Write-Finding "WSUS configured with HTTP (no SSL) - potential MitM attack vector: $($wsus.WUServer)" "Critical"
    } elseif ($wsus.WUServer) {
        Write-Finding "WSUS Server: $($wsus.WUServer)" "Info"
    }
    
} catch {
    Write-Finding "Error analyzing security policies: $_" "High"
}

# ============================================================================
# COM/DCOM ANALYSIS
# ============================================================================
Write-SectionHeader "COM/DCOM CONFIGURATION ANALYSIS"

try {
    Write-Finding "Analyzing COM/DCOM configuration..." "Info"
    
    # DCOM permissions
    Write-Finding "`nChecking DCOM permissions..." "Info"
    $dcomConfig = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Ole" -ErrorAction SilentlyContinue
    
    if ($dcomConfig) {
        Write-Finding "DCOM is configured on this system" "Info"
    }
    
    # Check for weak DCOM application permissions
    Write-Finding "`nEnumerating DCOM Applications..." "Info"
    $dcomApps = Get-CimInstance -ClassName Win32_DCOMApplication | Select-Object -First 20 AppID, Name
    
    foreach ($app in $dcomApps) {
        Write-Finding "DCOM App: $($app.Name) - AppID: $($app.AppID)" "Info"
    }
    
    # COM hijacking opportunities via registry
    Write-Finding "`nChecking for COM hijacking opportunities..." "Info"
    $userCLSID = "HKCU:\Software\Classes\CLSID"
    if (Test-Path $userCLSID) {
        $clsids = Get-ChildItem -Path $userCLSID -ErrorAction SilentlyContinue
        if ($clsids.Count -gt 0) {
            Write-Finding "User-level CLSID registrations found: $($clsids.Count)" "Medium"
            Write-Finding "Potential COM hijacking via user registry hive" "Medium"
        }
    }
    
    # Check if current user can modify system COM registrations
    $systemCLSID = "HKLM:\Software\Classes\CLSID"
    try {
        $acl = Get-Acl "HKLM:\Software\Classes\CLSID" -ErrorAction Stop
        $writable = $acl.Access | Where-Object {
            ($_.RegistryRights -match "Write|FullControl") -and
            ($_.IdentityReference -match "Users|Everyone|$env:USERNAME")
        }
        
        if ($writable) {
            Write-Finding "SYSTEM COM registry is WRITABLE by current user - COM hijacking possible!" "Critical"
        }
    } catch {}
    
} catch {
    Write-Finding "Error analyzing COM/DCOM: $_" "High"
}

# ============================================================================
# APPLOCKER / WDAC BYPASS CHECKS
# ============================================================================
Write-SectionHeader "APPLOCKER / WDAC CONFIGURATION"

try {
    Write-Finding "Checking AppLocker configuration..." "Info"
    
    # Check if AppLocker is enabled
    $appLockerPolicy = Get-AppLockerPolicy -Effective -ErrorAction SilentlyContinue
    
    if ($appLockerPolicy) {
        Write-Finding "AppLocker IS configured on this system!" "Info"
        
        # Check each rule collection
        foreach ($ruleCollection in $appLockerPolicy.RuleCollections) {
            Write-Finding "`nRule Collection: $($ruleCollection.RuleCollectionType)" "Info"
            Write-Finding "Enforcement Mode: $($ruleCollection.EnforcementMode)" "Medium"
            
            # Look for path rules that might be writable
            foreach ($rule in $ruleCollection) {
                if ($rule.Path) {
                    Write-Finding "  Path Rule: $($rule.Path)" "Info"
                    
                    # Check if path is writable
                    $testPath = $rule.Path -replace '\*.*$', ''
                    if (Test-Path $testPath -ErrorAction SilentlyContinue) {
                        try {
                            $acl = Get-Acl $testPath -ErrorAction SilentlyContinue
                            $writable = $acl.Access | Where-Object {
                                ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users|$env:USERNAME")
                            }
                            
                            if ($writable) {
                                Write-Finding "    ^-- Path is WRITABLE - AppLocker bypass possible!" "Critical"
                            }
                        } catch {}
                    }
                }
            }
        }
        
        # Common AppLocker bypass paths
        Write-Finding "`nChecking common AppLocker bypass locations..." "Info"
        $bypassPaths = @(
            "C:\Windows\Tasks",
            "C:\Windows\Temp",
            "C:\Windows\tracing",
            "C:\Windows\System32\spool\drivers\color",
            "C:\Windows\System32\spool\printers",
            "C:\Windows\System32\spool\servers",
            "C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys",
            "C:\Windows\System32\Tasks",
            "C:\ProgramData"
        )
        
        foreach ($path in $bypassPaths) {
            if (Test-Path $path -ErrorAction SilentlyContinue) {
                try {
                    $testFile = Join-Path $path "test_$(Get-Random).exe"
                    New-Item -Path $testFile -ItemType File -ErrorAction Stop | Out-Null
                    Remove-Item -Path $testFile -ErrorAction SilentlyContinue
                    Write-Finding "WRITABLE bypass path: $path" "Critical"
                } catch {}
            }
        }
        
    } else {
        Write-Finding "AppLocker is NOT configured" "Info"
    }
    
    # Check WDAC (Windows Defender Application Control)
    Write-Finding "`nChecking WDAC/Device Guard..." "Info"
    $wdacStatus = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard -ErrorAction SilentlyContinue
    
    if ($wdacStatus) {
        Write-Finding "Code Integrity Policy Enforcement Status: $($wdacStatus.CodeIntegrityPolicyEnforcementStatus)" "Info"
        Write-Finding "User Mode Code Integrity Policy Enforcement Status: $($wdacStatus.UsermodeCodeIntegrityPolicyEnforcementStatus)" "Info"
        
        if ($wdacStatus.CodeIntegrityPolicyEnforcementStatus -eq 0) {
            Write-Finding "WDAC/Device Guard is NOT enforced" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error checking AppLocker/WDAC: $_" "High"
}

# ============================================================================
# STARTUP FOLDERS & SHELL FOLDERS
# ============================================================================
Write-SectionHeader "STARTUP FOLDERS & SHELL FOLDERS"

try {
    Write-Finding "Checking startup folder permissions..." "Info"
    
    $startupFolders = @(
        "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup",
        "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
    )
    
    foreach ($folder in $startupFolders) {
        if (Test-Path $folder) {
            Write-Finding "`nStartup Folder: $folder" "Info"
            
            # List contents
            $items = Get-ChildItem -Path $folder -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                Write-Finding "  Contains: $($item.Name)" "Medium"
            }
            
            # Check permissions
            try {
                $acl = Get-Acl $folder -ErrorAction SilentlyContinue
                $writable = $acl.Access | Where-Object {
                    ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                    ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                }
                
                if ($writable) {
                    Write-Finding "  ^-- Folder is WRITABLE by unprivileged users!" "Critical"
                }
            } catch {}
        }
    }
    
    # Check shell folder registry keys
    Write-Finding "`nChecking Shell Folder registry keys..." "Info"
    $shellKeys = @(
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders"
    )
    
    foreach ($key in $shellKeys) {
        if (Test-Path $key) {
            $props = Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
            $props.PSObject.Properties | Where-Object {$_.Name -notmatch "^PS"} | ForEach-Object {
                if ($_.Value -match "C:\\Windows") {
                    Write-Finding "Suspicious shell folder: $($_.Name) = $($_.Value)" "Medium"
                }
            }
        }
    }
    
} catch {
    Write-Finding "Error checking startup folders: $_" "High"
}

# ============================================================================
# WINDOWS SERVICES - DEEP DIVE
# ============================================================================
Write-SectionHeader "WINDOWS SERVICES - DEEP ANALYSIS"

try {
    Write-Finding "Performing deep service analysis..." "Info"
    
    $services = Get-WmiObject win32_service
    
    # Check service registry key permissions
    Write-Finding "`nChecking service registry key permissions..." "Info"
    $serviceRegPath = "HKLM:\SYSTEM\CurrentControlSet\Services"
    
    Get-ChildItem -Path $serviceRegPath -ErrorAction SilentlyContinue | Select-Object -First 30 | ForEach-Object {
        try {
            $acl = Get-Acl $_.PSPath -ErrorAction SilentlyContinue
            $writable = $acl.Access | Where-Object {
                ($_.RegistryRights -match "Write|FullControl|SetValue") -and
                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users|$env:USERNAME")
            }
            
            if ($writable) {
                Write-Finding "WRITABLE service registry key: $($_.PSChildName)" "Critical"
            }
        } catch {}
    }
    
    # Check for service DLL hijacking
    Write-Finding "`nChecking for service DLL hijacking opportunities..." "Info"
    foreach ($service in $services | Select-Object -First 50) {
        $serviceName = $service.Name
        $regPath = "HKLM:\SYSTEM\CurrentControlSet\Services\$serviceName\Parameters"
        
        if (Test-Path $regPath) {
            $params = Get-ItemProperty -Path $regPath -ErrorAction SilentlyContinue
            
            if ($params.ServiceDll) {
                $dllPath = $params.ServiceDll
                $dllDir = Split-Path $dllPath -Parent
                
                if (Test-Path $dllDir -ErrorAction SilentlyContinue) {
                    try {
                        $acl = Get-Acl $dllDir -ErrorAction SilentlyContinue
                        $writable = $acl.Access | Where-Object {
                            ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                            ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                        }
                        
                        if ($writable) {
                            Write-Finding "Service DLL directory is WRITABLE: $serviceName - $dllDir" "Critical"
                        }
                    } catch {}
                }
            }
        }
    }
    
    # Check service failure actions
    Write-Finding "`nChecking service failure actions..." "Info"
    foreach ($service in $services | Where-Object {$_.StartMode -eq "Auto"} | Select-Object -First 20) {
        try {
            $failureActions = & sc.exe qfailure $service.Name 2>$null
            if ($failureActions -match "COMMAND_LINE.*exe") {
                $commandLine = ($failureActions | Select-String "COMMAND_LINE").ToString()
                Write-Finding "Service with failure command: $($service.Name) - $commandLine" "Medium"
                
                # Check if command is writable
                $exePath = $commandLine -replace '.*COMMAND_LINE\s*:\s*', '' -replace '"', '' -replace ' .*$', ''
                if ($exePath -and (Test-Path $exePath -ErrorAction SilentlyContinue)) {
                    try {
                        $acl = Get-Acl $exePath -ErrorAction SilentlyContinue
                        $writable = $acl.Access | Where-Object {
                            ($_.FileSystemRights -match "Write|Modify|FullControl") -and
                            ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
                        }
                        
                        if ($writable) {
                            Write-Finding "  ^-- Failure action executable is WRITABLE!" "Critical"
                        }
                    } catch {}
                }
            }
        } catch {}
    }
    
} catch {
    Write-Finding "Error in deep service analysis: $_" "High"
}

# ============================================================================
# FILE SYSTEM TRICKS
# ============================================================================
Write-SectionHeader "FILE SYSTEM TRICKS & LINKS"

try {
    Write-Finding "Checking for symbolic links and mount points..." "Info"
    
    # Check for symlinks in common locations
    $commonPaths = @("C:\", "C:\Windows", "C:\Program Files", "C:\Users")
    
    foreach ($path in $commonPaths) {
        if (Test-Path $path) {
            Get-ChildItem -Path $path -Force -ErrorAction SilentlyContinue | Where-Object {
                $_.Attributes -match "ReparsePoint"
            } | Select-Object -First 10 | ForEach-Object {
                Write-Finding "Reparse Point found: $($_.FullName)" "Medium"
                
                # Check target
                try {
                    $target = $_.Target
                    if ($target) {
                        Write-Finding "  Target: $target" "Info"
                    }
                } catch {}
            }
        }
    }
    
    # Check for junction points
    Write-Finding "`nChecking for junction points..." "Info"
    $junctions = Get-ChildItem -Path "C:\" -Directory -Force -ErrorAction SilentlyContinue | 
                 Where-Object {$_.Attributes -match "ReparsePoint"} |
                 Select-Object -First 10
    
    foreach ($junction in $junctions) {
        Write-Finding "Junction: $($junction.FullName)" "Info"
    }
    
} catch {
    Write-Finding "Error checking file system tricks: $_" "High"
}

# ============================================================================
# BROWSER DATA EXTRACTION
# ============================================================================
Write-SectionHeader "BROWSER DATA & CREDENTIALS"

try {
    Write-Finding "Searching for browser data..." "Info"
    
    # Chrome
    $chromeLoginData = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data"
    if (Test-Path $chromeLoginData) {
        Write-Finding "Chrome Login Data found: $chromeLoginData" "High"
        Write-Finding "  Use tools like 'SharpChrome' or 'ChromePass' to decrypt" "Info"
    }
    
    $chromeCookies = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies"
    if (Test-Path $chromeCookies) {
        Write-Finding "Chrome Cookies found: $chromeCookies" "Medium"
    }
    
    $chromeHistory = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History"
    if (Test-Path $chromeHistory) {
        Write-Finding "Chrome History found: $chromeHistory" "Medium"
    }
    
    # Firefox
    $firefoxProfiles = "$env:APPDATA\Mozilla\Firefox\Profiles"
    if (Test-Path $firefoxProfiles) {
        Write-Finding "Firefox profiles found: $firefoxProfiles" "High"
        Get-ChildItem -Path $firefoxProfiles -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            $loginJson = Join-Path $_.FullName "logins.json"
            if (Test-Path $loginJson) {
                Write-Finding "  Firefox logins.json: $loginJson" "High"
            }
            
            $key4db = Join-Path $_.FullName "key4.db"
            if (Test-Path $key4db) {
                Write-Finding "  Firefox key4.db: $key4db" "High"
            }
        }
    }
    
    # Edge
    $edgeLoginData = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Login Data"
    if (Test-Path $edgeLoginData) {
        Write-Finding "Edge Login Data found: $edgeLoginData" "High"
    }
    
    # IE/Edge Legacy
    $ieCredentials = "$env:LOCALAPPDATA\Microsoft\Credentials"
    if (Test-Path $ieCredentials) {
        $credFiles = Get-ChildItem -Path $ieCredentials -File -ErrorAction SilentlyContinue
        if ($credFiles) {
            Write-Finding "IE/Edge credential files found: $($credFiles.Count) files" "High"
        }
    }
    
} catch {
    Write-Finding "Error extracting browser data: $_" "High"
}

# ============================================================================
# CLIPBOARD & RECENT ITEMS
# ============================================================================
Write-SectionHeader "CLIPBOARD & RECENT ACTIVITY"

try {
    Write-Finding "Checking clipboard history..." "Info"
    
    # Try to get current clipboard content
    try {
        Add-Type -AssemblyName System.Windows.Forms -ErrorAction SilentlyContinue
        $clipboard = [System.Windows.Forms.Clipboard]::GetText()
        if ($clipboard) {
            $preview = $clipboard.Substring(0, [Math]::Min(100, $clipboard.Length))
            Write-Finding "Current clipboard content (first 100 chars): $preview" "Medium"
        }
    } catch {}
    
    # Recent documents
    Write-Finding "`nChecking recent documents..." "Info"
    $recentPath = "$env:APPDATA\Microsoft\Windows\Recent"
    if (Test-Path $recentPath) {
        $recentItems = Get-ChildItem -Path $recentPath -ErrorAction SilentlyContinue | Select-Object -First 20
        Write-Finding "Recent items found: $($recentItems.Count)" "Info"
        
        foreach ($item in $recentItems) {
            if ($item.Extension -eq ".lnk") {
                Write-Finding "  $($item.Name)" "Info"
            }
        }
    }
    
    # Jump lists
    Write-Finding "`nChecking jump lists..." "Info"
    $jumpListPath = "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations"
    if (Test-Path $jumpListPath) {
        $jumpLists = Get-ChildItem -Path $jumpListPath -ErrorAction SilentlyContinue
        Write-Finding "Jump list files found: $($jumpLists.Count)" "Medium"
    }
    
    # Office recent files
    $officeRecent = "$env:APPDATA\Microsoft\Office\Recent"
    if (Test-Path $officeRecent) {
        $officeFiles = Get-ChildItem -Path $officeRecent -ErrorAction SilentlyContinue
        if ($officeFiles) {
            Write-Finding "Office recent files: $($officeFiles.Count)" "Info"
        }
    }
    
} catch {
    Write-Finding "Error checking clipboard/recent items: $_" "High"
}

# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================
Write-SectionHeader "ENVIRONMENT VARIABLES ANALYSIS"

try {
    Write-Finding "Analyzing environment variables..." "Info"
    
    $envVars = Get-ChildItem Env:
    
    # Look for credentials or sensitive data
    foreach ($var in $envVars) {
        if ($var.Name -match "PASSWORD|PWD|SECRET|KEY|TOKEN|API|CREDENTIAL") {
            Write-Finding "Suspicious environment variable: $($var.Name) = $($var.Value)" "High"
        }
    }
    
    # Check PATH for current directory
    if ($env:PATH -match "^\.;|;\.;|;\.$") {
        Write-Finding "Current directory (.) is in PATH - DLL hijacking risk!" "Critical"
    }
    
    # Display all env vars for review
    Write-Finding "`nAll Environment Variables:" "Info"
    $envVars | Sort-Object Name | ForEach-Object {
        Write-Finding "$($_.Name) = $($_.Value)" "Info"
    }
    
} catch {
    Write-Finding "Error analyzing environment variables: $_" "High"
}

# ============================================================================
# FIREWALL CONFIGURATION
# ============================================================================
Write-SectionHeader "FIREWALL CONFIGURATION"

try {
    Write-Finding "Checking Windows Firewall status..." "Info"
    
    $firewallProfiles = Get-NetFirewallProfile -ErrorAction SilentlyContinue
    
    foreach ($profile in $firewallProfiles) {
        Write-Finding "`nProfile: $($profile.Name)" "Info"
        Write-Finding "  Enabled: $($profile.Enabled)" "Info"
        
        if (-not $profile.Enabled) {
            Write-Finding "  ^-- FIREWALL IS DISABLED!" "Critical"
        }
        
        Write-Finding "  Default Inbound Action: $($profile.DefaultInboundAction)" "Info"
        Write-Finding "  Default Outbound Action: $($profile.DefaultOutboundAction)" "Info"
    }
    
    # Check for interesting firewall rules
    Write-Finding "`nChecking firewall rules..." "Info"
    $rules = Get-NetFirewallRule -Enabled True -Direction Inbound -ErrorAction SilentlyContinue | Select-Object -First 30
    
    foreach ($rule in $rules) {
        if ($rule.Action -eq "Allow") {
            $addressFilter = Get-NetFirewallAddressFilter -AssociatedNetFirewallRule $rule -ErrorAction SilentlyContinue
            $portFilter = Get-NetFirewallPortFilter -AssociatedNetFirewallRule $rule -ErrorAction SilentlyContinue
            
            if ($addressFilter.RemoteAddress -eq "Any" -and $portFilter.LocalPort) {
                Write-Finding "Open inbound rule: $($rule.DisplayName) - Port: $($portFilter.LocalPort)" "Medium"
            }
        }
    }
    
} catch {
    Write-Finding "Error checking firewall: $_" "High"
}

# ============================================================================
# WINDOWS SUBSYSTEM FOR LINUX (WSL)
# ============================================================================
Write-SectionHeader "WINDOWS SUBSYSTEM FOR LINUX (WSL)"

try {
    Write-Finding "Checking for WSL installation..." "Info"
    
    # Check if WSL is installed
    $wslInstalled = Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux -ErrorAction SilentlyContinue
    
    if ($wslInstalled.State -eq "Enabled") {
        Write-Finding "WSL IS INSTALLED!" "High"
        
        # List WSL distributions
        try {
            $wslDistros = & wsl.exe -l -v 2>$null
            if ($wslDistros) {
                Write-Finding "WSL Distributions:" "High"
                $wslDistros | ForEach-Object { Write-Finding $_ "Info" }
            }
        } catch {}
        
        # Check WSL configuration
        $wslConfig = "$env:USERPROFILE\.wslconfig"
        if (Test-Path $wslConfig) {
            Write-Finding "WSL config found: $wslConfig" "Medium"
        }
        
        Write-Finding "Potential escape vector via WSL to Linux environment" "High"
        
    } else {
        Write-Finding "WSL is not installed" "Info"
    }
    
} catch {
    Write-Finding "Error checking WSL: $_" "High"
}

# ============================================================================
# JUICY FOLDERS & FILES
# ============================================================================
Write-SectionHeader "JUICY FOLDERS & SENSITIVE FILES"

try {
    Write-Finding "Searching juicy locations for sensitive files..." "Info"
    
    # Desktop
    Write-Finding "`nDesktop files:" "Info"
    $desktopFiles = Get-ChildItem -Path "$env:USERPROFILE\Desktop" -File -ErrorAction SilentlyContinue | Select-Object -First 20
    foreach ($file in $desktopFiles) {
        if ($file.Extension -match "\.txt|\.doc|\.docx|\.xls|\.xlsx|\.pdf|\.key|\.pem|\.ppk") {
            Write-Finding "  $($file.Name)" "Medium"
        }
    }
    
    # Downloads
    Write-Finding "`nDownloads folder:" "Info"
    $downloads = Get-ChildItem -Path "$env:USERPROFILE\Downloads" -File -ErrorAction SilentlyContinue | 
                 Where-Object {$_.Extension -match "\.txt|\.doc|\.docx|\.xls|\.xlsx|\.pdf|\.key|\.pem|\.ppk|\.kdbx"} |
                 Select-Object -First 20
    foreach ($file in $downloads) {
        Write-Finding "  $($file.Name)" "Medium"
    }
    
    # Documents
    Write-Finding "`nDocuments folder (interesting files):" "Info"
    $docs = Get-ChildItem -Path "$env:USERPROFILE\Documents" -File -Recurse -ErrorAction SilentlyContinue -Depth 1 |
            Where-Object {$_.Extension -match "\.key|\.pem|\.ppk|\.kdbx|\.wallet"} |
            Select-Object -First 20
    foreach ($file in $docs) {
        Write-Finding "  $($file.FullName)" "High"
    }
    
    # SSH keys
    $sshPath = "$env:USERPROFILE\.ssh"
    if (Test-Path $sshPath) {
        Write-Finding "`nSSH directory found!" "High"
        Get-ChildItem -Path $sshPath -File -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  $($_.Name)" "High"
        }
    }
    
    # AWS credentials
    $awsPath = "$env:USERPROFILE\.aws"
    if (Test-Path $awsPath) {
        Write-Finding "`nAWS directory found!" "Critical"
        Get-ChildItem -Path $awsPath -File -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  $($_.Name)" "Critical"
        }
    }
    
    # Azure CLI
    $azurePath = "$env:USERPROFILE\.azure"
    if (Test-Path $azurePath) {
        Write-Finding "`nAzure CLI directory found!" "Critical"
    }
    
    # Docker config
    $dockerPath = "$env:USERPROFILE\.docker"
    if (Test-Path $dockerPath) {
        Write-Finding "`nDocker config directory found!" "High"
        $dockerConfig = "$dockerPath\config.json"
        if (Test-Path $dockerConfig) {
            Write-Finding "  Docker config.json found (may contain registry credentials)" "High"
        }
    }
    
    # KeePass databases
    Write-Finding "`nSearching for password databases..." "Info"
    $kdbxFiles = Get-ChildItem -Path "$env:USERPROFILE" -Filter "*.kdbx" -Recurse -ErrorAction SilentlyContinue -Depth 3 | Select-Object -First 10
    foreach ($kdbx in $kdbxFiles) {
        Write-Finding "KeePass database: $($kdbx.FullName)" "Critical"
    }
    
    # Recycle Bin
    Write-Finding "`nChecking Recycle Bin..." "Info"
    $recycleBin = "C:\`$Recycle.Bin"
    if (Test-Path $recycleBin) {
        $recycledItems = Get-ChildItem -Path $recycleBin -Recurse -ErrorAction SilentlyContinue | Select-Object -First 10
        if ($recycledItems) {
            Write-Finding "Items in Recycle Bin: $($recycledItems.Count)" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error searching juicy folders: $_" "High"
}

# ============================================================================
# AMSI STATUS
# ============================================================================
Write-SectionHeader "AMSI (ANTI-MALWARE SCAN INTERFACE)"

try {
    Write-Finding "Checking AMSI status..." "Info"
    
    # Check if AMSI is loaded
    $amsiLoaded = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.Location -like "*amsi.dll*"}
    
    if ($amsiLoaded) {
        Write-Finding "AMSI is loaded in current process" "Info"
    } else {
        Write-Finding "AMSI does not appear to be loaded" "Medium"
    }
    
    # Check AMSI registry settings
    $amsiReg = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\AMSI" -ErrorAction SilentlyContinue
    if ($amsiReg) {
        Write-Finding "AMSI registry key exists" "Info"
    }
    
    # Check for AMSI providers
    $amsiProviders = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\AMSI\Providers" -ErrorAction SilentlyContinue
    if ($amsiProviders) {
        Write-Finding "AMSI Providers registered: $($amsiProviders.Count)" "Info"
        foreach ($provider in $amsiProviders) {
            Write-Finding "  Provider: $($provider.PSChildName)" "Info"
        }
    }
    
    Write-Finding "`nNote: AMSI can be bypassed in many ways if not properly protected" "Info"
    
} catch {
    Write-Finding "Error checking AMSI: $_" "High"
}

# ============================================================================
# EVENT LOGS
# ============================================================================
Write-SectionHeader "EVENT LOG ANALYSIS"

try {
    Write-Finding "Analyzing event log configuration..." "Info"
    
    # Check if we can read security logs
    try {
        $securityLog = Get-EventLog -LogName Security -Newest 1 -ErrorAction Stop
        Write-Finding "CAN read Security event log!" "High"
    } catch {
        Write-Finding "Cannot read Security event log (access denied)" "Info"
    }
    
    # Check event log settings
    $logSettings = Get-EventLog -List -ErrorAction SilentlyContinue
    
    foreach ($log in $logSettings) {
        if ($log.Log -match "Security|System|Application") {
            Write-Finding "`n$($log.Log) Log:" "Info"
            Write-Finding "  Max Size: $($log.MaximumKilobytes) KB" "Info"
            Write-Finding "  Overflow Action: $($log.OverflowAction)" "Info"
            Write-Finding "  Entries: $($log.Entries.Count)" "Info"
            
            if ($log.OverflowAction -eq "OverwriteAsNeeded") {
                Write-Finding "  ^-- Log can be overwritten (evidence may be lost)" "Medium"
            }
        }
    }
    
    # Check for cleared logs (potential attacker activity)
    Write-Finding "`nChecking for recently cleared logs..." "Info"
    try {
        $clearedLogs = Get-WinEvent -FilterHashtable @{LogName='Security'; ID=1102} -MaxEvents 10 -ErrorAction SilentlyContinue
        if ($clearedLogs) {
            Write-Finding "Security log was CLEARED recently!" "Critical"
            foreach ($event in $clearedLogs) {
                Write-Finding "  Cleared at: $($event.TimeCreated) by $($event.Properties[1].Value)" "Critical"
            }
        }
    } catch {}
    
    # Check audit policy
    Write-Finding "`nCurrent Audit Policy:" "Info"
    $auditSettings = auditpol /get /category:* | Select-String "Success|Failure"
    $enabledAudits = ($auditSettings | Measure-Object).Count
    Write-Finding "Audit settings configured: $enabledAudits" "Info"
    
    if ($enabledAudits -lt 10) {
        Write-Finding "Very few audit policies enabled - poor logging coverage" "Medium"
    }
    
} catch {
    Write-Finding "Error analyzing event logs: $_" "High"
}

# ============================================================================
# SHADOW COPIES (VSS)
# ============================================================================
Write-SectionHeader "SHADOW COPIES (VOLUME SHADOW COPY SERVICE)"

try {
    Write-Finding "Checking for Volume Shadow Copies..." "Info"
    
    # List shadow copies
    $shadowCopies = Get-WmiObject Win32_ShadowCopy -ErrorAction SilentlyContinue
    
    if ($shadowCopies) {
        Write-Finding "Shadow copies found: $($shadowCopies.Count)" "High"
        
        foreach ($shadow in $shadowCopies) {
            Write-Finding "`nShadow Copy:" "High"
            Write-Finding "  ID: $($shadow.ID)" "Info"
            Write-Finding "  Volume: $($shadow.VolumeName)" "Info"
            Write-Finding "  Install Date: $($shadow.InstallDate)" "Info"
            Write-Finding "  Device Object: $($shadow.DeviceObject)" "Info"
        }
        
        Write-Finding "`nShadow copies may contain old versions of sensitive files!" "High"
        Write-Finding "Access via: mklink /d C:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy[N]\" "Info"
        
    } else {
        Write-Finding "No shadow copies found" "Info"
    }
    
    # Check VSS service status
    $vssService = Get-Service -Name VSS -ErrorAction SilentlyContinue
    if ($vssService) {
        Write-Finding "`nVSS Service Status: $($vssService.Status)" "Info"
    }
    
} catch {
    Write-Finding "Error checking shadow copies: $_" "High"
}

# ============================================================================
# PRINT SPOOLER
# ============================================================================
Write-SectionHeader "PRINT SPOOLER SERVICE"

try {
    Write-Finding "Checking Print Spooler configuration..." "Info"
    
    $spooler = Get-Service -Name Spooler -ErrorAction SilentlyContinue
    
    if ($spooler) {
        Write-Finding "Print Spooler Status: $($spooler.Status)" "Info"
        Write-Finding "Start Type: $($spooler.StartType)" "Info"
        
        if ($spooler.Status -eq "Running") {
            Write-Finding "Print Spooler is RUNNING - potential PrintNightmare vulnerability!" "Critical"
            
            # Check if point and print restrictions are enabled
            $pointAndPrint = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint" -ErrorAction SilentlyContinue
            
            if ($pointAndPrint) {
                Write-Finding "`nPoint and Print settings:" "Info"
                Write-Finding "  RestrictDriverInstallationToAdministrators: $($pointAndPrint.RestrictDriverInstallationToAdministrators)" "Info"
                Write-Finding "  NoWarningNoElevationOnInstall: $($pointAndPrint.NoWarningNoElevationOnInstall)" "Info"
                
                if ($pointAndPrint.NoWarningNoElevationOnInstall -eq 1) {
                    Write-Finding "  ^-- NoWarningNoElevationOnInstall is enabled - VULNERABLE to PrintNightmare!" "Critical"
                }
            } else {
                Write-Finding "Point and Print restrictions not configured - potentially vulnerable" "High"
            }
        }
    }
    
    # Check printer ports
    Write-Finding "`nInstalled Printers:" "Info"
    $printers = Get-Printer -ErrorAction SilentlyContinue | Select-Object -First 10
    foreach ($printer in $printers) {
        Write-Finding "  $($printer.Name) - Port: $($printer.PortName)" "Info"
    }
    
} catch {
    Write-Finding "Error checking Print Spooler: $_" "High"
}

# ============================================================================
# SUMMARY
# ============================================================================
Write-SectionHeader "ENUMERATION COMPLETE"

Write-Finding "Enumeration completed at $(Get-Date)" "Info"
if ($SaveReport) {
    Write-Finding "Report saved to: $OutputPath" "Info"
}

Write-Host "`n[i] Remember: Always get proper authorization before testing!" -ForegroundColor Yellow
Write-Host "[i] This tool is for educational and authorized assessment purposes only.`n" -ForegroundColor Yellow
